2025-11-06

Сделано:
- How Python stores and handles data in variables of different types.
- The difference between mutable and immutable data types.
- What is branching in python (if/else)
- Logical Operators (and/or/not)
- Slicing/function len()
- Maths functions: min/max/abs/round

# Bash

# GIT

GIT. Как перенести изменение с одной ветки на другую?
Если ты ещё не добавил изменение в индекс, то просто переключись на другую ветку.
Если ты уже добавил изменение в индекс, то просто переключись на другую ветку.

# Python

Python. Что такое "Семантика присваивания"?
aka Семантика хранения и передачи данных; Assignment / Storage / Evaluation / Binding Semantics.
Это принцип, по которому объект данных (переменная) формируется на уровне памяти.
По умолчанию язык C формирует объект данных по модели значений (value semantics): в ней переменная, данные и область памяти представляют собой один и тот же объект. Переменной выделяется конкретная область памяти, и эта область закрепляется за конкретной переменной, создавая связь "один к одному".
По умолчанию язык Python формирует объект данных по модели ссылок (reference Semantics): в ней переменная и данные разделены. Данным выделяется одна область памяти, с присваиванием уникального идентификатора, а переменной - другая область памяти, в которой хранится этот идентификатор. Таким образом, переменная ссылается на данные, а не содержит их непосредственно. Данная модель открывает возможность создания связи "многие к одному", при которой множество переменных может ссылаться на один и тот же объект данных.

Python. В чём преимущество модели ссылок относитель модели значений?
Главное преимущество состоит в отсутствии дублирования объектов данных. Например, по умолчанию в языке C при передаче переменной в функцию создаётся копия её данных: параметру функции выделяется отдельная область памяти, в которой хранится дубликат исходных данных. Таким образом, в памяти оказываются две области с идентичным содержимым. Если данные малы — это не проблема, но если речь идёт, например, о массиве на гигабайты, это приводит к существенным затратам памяти.
В Python параметр функции так же является переменной, и так же содержит только идентификатор области памяти, в которой хранятся данные. В результате и исходная переменная, и параметр функции — это две "лёгкие" ссылки на один и тот же объект данных в памяти, без его копирования.

Python. В чём принципиальное отличие Python от C с точки зрения семантики присваивания?
Отличие заключается в выборе модели по умолчанию. И C, и Python позволяют реализовать как модель "один к одному" (когда переменная и данные находятся в одной области памяти), так и модель "многие к одному" (когда несколько переменных ссылаются на один и тот же объект данных). Оба языка также позволяют как передавать данные в функцию с их копированием, так и передавать ссылку на уже существующие данные.
Однако в языке C по умолчанию используется модель значений: присваивание и передача аргумента приводят к копированию данных, что создаёт связь "один к одному" между переменной и её значением.
В Python по умолчанию используется модель ссылок: переменная хранит лишь идентификатор объекта, и присваивание создает связь "многие к одному", то есть несколько переменных могут ссылаться на один и тот же объект данных без его дублирования.

Python. Что такое изменяемые (mutable) и неизменяемые (immutable) типы данных?
В Python любая переменная хранит ссылку на область памяти, в которой находится объект данных. Несколько переменных могут ссылаться на один и тот же объект. Однако поведение при изменении зависит от типа данных.
Изменяемые типы (mutable) позволяют изменять содержимое и размер области памяти без изменения её идентификатора. Примеры: list, dict, set, bytearray.
Неизменяемые типы (immutable) не позволяют изменять содержимое и размер области памяти без изменения её идентификатора. Любая попытка изменить значение приводит к созданию новой области, с новым идентификатор, новым размером и новым содержимым. Примеры: int, float, str, tuple, bool, frozenset.

Python. Какие типы данных относятся к изменяемым, а какие к неизменяемым в стандартном пакете языка?
Изменяемые: list; dict; set; bytearray.
Неизменяемые: int; float; bool; str; tuple; frozenset; bytes.

Python. Как проверить к какому типу данных относится тип данных: к изменяемым или к неизменяемым?
1. Самым простым способом является проверка наличия у типа данных методов типа: add; update; append; extend; remove; insert; delete; pop; clear и т.д. Если есть, то с вероятностью в 99,99% это изменяемый тип данных.
2. С помощью проверки идентификатора.

Шаблон:
x = something
before = id(x)
# попытка изменить
...
after = id(x)

if before == after:
    print("Изменяемый")
else:
    print("Неизменяемый")

Пример #1:
x = 10
print(id(x))
x += 1
print(id(x))     # id изменился → неизменяемый

Пример #2:
lst = [1,2,3]
print(id(lst))
lst.append(4)
print(id(lst))   # id тот же → изменяемый

3. С помощью проверки хешируемости.

def is_mutable(obj):
    try:
        _ = hash(obj)
        return False  # если хешируется → скорее всего неизменяем
    except TypeError:
        return True   # если не хешируется → точно изменяем

Все неизменяемые типы в Python должны быть хешируемыми, чтобы их можно было использовать как ключи в dict.
Все изменяемые типы — не хешируемые, чтобы избежать ошибок «тихий объект поменялся, а ключ в словаре нет».

print(is_mutable(10))           # False
print(is_mutable("hello"))      # False
print(is_mutable((1,2,3)))      # False
print(is_mutable([1,2,3]))      # True
print(is_mutable({"a":1}))      # True
print(is_mutable({1,2,3}))      # True

Python. Что такое ветвление?
Управление потоком данных в зависимости от условий.

Python. Какие есть конструкции ветвления?
if ... elif ... else ... (основная конструкция ветвления)
Тернарный оператор (условное выражение)
Ветвление внутри коллекций (условия в генераторах)
case

Python. Какова структура конструкции "if ... elif ... else ..."
if <condition>:
    <action>
[elif <condition:>
    <action>]
[else:
    <action>]

Python. Какова структура тернарного оператора (условного выражения)?
<variable> = <if_true> if <condition> else <if_false>

Python. Какова структура ветвления внутри коллекций (условия в генераторах)?
Условие в генераторах списков, словарей и множеств:
<variable> = [<action_if_true> for el in range(<n>) if <condition>]
squares = [x*x for x in range(10) if x % 2 == 0]
# [0, 4, 16, 36, 64]
Условие с else внутри генератора
<variable> = [<action_if_true> if <condition> else <action_if_false> for el in range(<n>)]
values = [x if x % 2 == 0 else -x for x in range(10)]
# [0, -1, 2, -3, 4, -5, 6, -7, 8, -9]

Python. Какова структура конструкции "case"?
match <command/expression>:
    case <value>[ | <value_2> | ... | <value_n>[ if <condition>]]:
        <action>
    [case <value>[ | <value_2> | ... | <value_n>[ if <condition>]]:
        <action>]
    [case _:
        <action>]

Python. Какова задача логических операторов (and, or, not)?
Создавать сложные и комплексные условия, объединяя, разъединяя или группируя условия.

Python. Что Python считает за False?
False
0
0.0
'' (пустая строка)
[], (), {} (пустые коллекции)
None

Python. Как работает оператор "and" / "И"?
Возвращает первое ложное значение, или последнее истинное значение, если ложных не было.
True and True -> True
True and False -> False
False and True -> False
False and False -> False

5 and 10 -> 10, потому что больше 0, а всё, что больше нуля, в любую сторону, является истинной.
0 and 10 -> 0, потому что 0 является ложью.

Python. Как работает оператор "or" / "ИЛИ"?
Возвращает первое истинное значение, или последнее ложное, если истинных не было.
True or True -> True
True or False -> True
False or True -> True
False or False -> False

0 or 10 -> 10, потому что больше 0, а всё, что больше нуля, в любую сторону, является истинной.
'' or 'hello' -> 'hello', потому что непустые строки являются истинной.
[] or [1] -> [1], потому что непустые коллекции являются истинной.
15 or 10 -> 15, потому что 15 было первым истинным значением.

Python. Как работает оператор "not" / "НЕ"?
Меняет истину на ложь, а ложь на истину.

not True -> False, потому что True = True, а True инвертируется в False.
not False -> True, потому что False = False, a False инвертируется в True.
not 0 -> True, потому что 0 = False, а False -> True.
not 1 -> False, потому что 1 = True, а True -> False.

Python. Как измерить длину строки?
len(<string>)

Python. Как подсчитать количество элементов в коллекции?
len(<collection>)

Python. Как вывести самую длинную строку в коллекции?
max(<collection>)

Python. Как вывести самое большое число в коллекции?
max(<collection>)

Python. Как вывести самую короткую строку в коллекции?
min(<collection>)
Пустая строка, тоже строка.

Python. Как вывести самое маленькое число в коллекции?
min(<collection>)

Python. Как вычислить модуль числа (конвертирует отрицательное в положительное, а положительно не трогает: neg. -> pos. / pos. -> pos.)?
abs(<number>)

Python. Как округлить дробное число до ближайшего целого?
round(<number>)

Python. Что выдаст: round(2.5)?
2

Python. Что выдаст: round(2.50)?
2

Python. Что выдаст: round(2.51)?
3

Python. Как округлить дробное число до n знаков после запятой?
round(<number>, <digits>)
